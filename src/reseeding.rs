// Copyright 2013 The Rust Project Developers. See the COPYRIGHT
// file at the top-level directory of this distribution and at
// http://rust-lang.org/COPYRIGHT.
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

//! A wrapper around another RNG that reseeds it after it
//! generates a certain number of random bytes.

use {Rng, SeedableRng, Error, ErrorKind};
#[cfg(feature="std")]
use NewSeeded;

/// How many bytes of entropy the underling RNG is allowed to generate
/// before it is reseeded
const DEFAULT_RESEEDING_THRESHOLD: i64 = 32 * 1024;

/// A wrapper around any RNG which reseeds the underlying RNG after it
/// has generated a certain number of random bytes.
/// 
/// Note that reseeding is considered advisory only. If reseeding fails, the
/// generator may delay reseeding or not reseed at all.
/// 
/// This derives `Clone` if both the inner RNG `R` and the reseeder `Rsdr` do.
/// Note that reseeders using external entropy should deliberately not
/// implement `Clone`.
#[derive(Debug, Clone)]
pub struct ReseedingRng<R, Rsdr: Reseeder<R>> {
    rng: R,
    threshold: i64,
    bytes_until_reseed: i64,
    /// Controls the behaviour when reseeding the RNG.
    pub reseeder: Rsdr,
}

impl<R: Rng, Rsdr: Reseeder<R>> ReseedingRng<R, Rsdr> {
    /// Create a new `ReseedingRng` with the given parameters.
    ///
    /// # Arguments
    ///
    /// * `rng`: the random number generator to use.
    /// * `threshold`: the amount of generated bytes after which to reseed the RNG.
    /// * `reseeder`: the reseeding object to use.
    pub fn new(rng: R, threshold: u64, reseeder: Rsdr) -> ReseedingRng<R,Rsdr> {
        assert!(threshold <= ::core::i64::MAX as u64);
        ReseedingRng {
            rng: rng,
            threshold: threshold as i64,
            bytes_until_reseed: threshold as i64,
            reseeder: reseeder
        }
    }

    /// Reseed the internal RNG if the number of bytes that have been
    /// generated exceed the threshold.
    /// 
    /// On error, this may delay reseeding or not reseed at all.
    #[inline(never)]
    pub fn reseed(&mut self) {
        let mut err_count = 0;
        loop {
            if let Err(e) = self.reseeder.reseed(&mut self.rng) {
                // TODO: log?
                if e.kind.should_wait() {
                    // Delay reseeding
                    self.bytes_until_reseed = self.threshold >> 8;
                    break;
                } else if e.kind.should_retry() {
                    if err_count > 4 {  // arbitrary limit
                        // TODO: log details & cause?
                        break;  // give up trying to reseed
                    }
                    err_count += 1;
                    continue;   // immediate retry
                } else {
                    break;  // give up trying to reseed
                }
            } else {
                break;  // no reseeding
            }
        }
        self.bytes_until_reseed = self.threshold;
    }
    /// Reseed the internal RNG if the number of bytes that have been
    /// generated exceed the threshold.
    /// 
    /// If reseeding fails, return an error with the original cause. Note that
    /// if the cause has a permanent failure, we report a transient error and
    /// skip reseeding.
    #[inline(never)]
    pub fn try_reseed(&mut self) -> Result<(), Error> {
        if let Err(err) = self.reseeder.reseed(&mut self.rng) {
            let newkind = match err.kind {
                a @ ErrorKind::NotReady => a,
                b @ ErrorKind::Transient => b,
                _ => {
                    self.bytes_until_reseed = self.threshold; // skip reseeding
                    ErrorKind::Transient
                }
            };
            return Err(Error::with_cause(newkind, "reseeding failed", err));
        }
        self.bytes_until_reseed = self.threshold;
        Ok(())
    }
}


impl<R: Rng, Rsdr: Reseeder<R>> Rng for ReseedingRng<R, Rsdr> {
    fn next_u32(&mut self) -> u32 {
        let value = self.rng.next_u32();
        self.bytes_until_reseed -= 4;
        if self.bytes_until_reseed <= 0 {
            self.reseed();
        }
        value
    }

    fn next_u64(&mut self) -> u64 {
        let value = self.rng.next_u64();
        self.bytes_until_reseed -= 8;
        if self.bytes_until_reseed <= 0 {
            self.reseed();
        }
        value
    }

    #[cfg(feature = "i128_support")]
    fn next_u128(&mut self) -> u128 {
        let value = self.rng.next_u128();
        self.bytes_until_reseed -= 16;
        if self.bytes_until_reseed <= 0 {
            self.reseed();
        }
        value
    }

    fn fill_bytes(&mut self, dest: &mut [u8]) {
        self.rng.fill_bytes(dest);
        self.bytes_until_reseed -= dest.len() as i64;
        if self.bytes_until_reseed <= 0 {
            self.reseed();
        }
    }

    fn try_fill(&mut self, dest: &mut [u8]) -> Result<(), Error> {
        self.rng.try_fill(dest)?;
        self.bytes_until_reseed -= dest.len() as i64;
        if self.bytes_until_reseed <= 0 {
            self.try_reseed()?;
        }
        Ok(())
    }
}

impl<R: SeedableRng, Rsdr: Reseeder<R>> ReseedingRng<R, Rsdr> {
    /// Create a new `ReseedingRng` from the given reseeder and
    /// seed. This uses a default value for `threshold`.
    pub fn from_reseeder(rsdr: Rsdr, seed: <R as SeedableRng>::Seed) -> ReseedingRng<R, Rsdr> {
        ReseedingRng {
            rng: SeedableRng::from_seed(seed),
            threshold: DEFAULT_RESEEDING_THRESHOLD,
            bytes_until_reseed: DEFAULT_RESEEDING_THRESHOLD,
            reseeder: rsdr
        }
    }
}

/// Something that can be used to reseed an RNG via `ReseedingRng`.
/// 
/// Note that implementations should support `Clone` only if reseeding is
/// deterministic (no external entropy source). This is so that a `ReseedingRng`
/// only supports `Clone` if fully deterministic.
pub trait Reseeder<R: ?Sized> {
    /// Reseed the given RNG.
    /// 
    /// On error, this should just forward the source error; errors are handled
    /// by the caller.
    fn reseed(&mut self, rng: &mut R) -> Result<(), Error>;
}

/// Reseed an RNG using `NewSeeded` to replace the current instance.
#[cfg(feature="std")]
#[derive(Debug)]
pub struct ReseedWithNew;

#[cfg(feature="std")]
impl<R: Rng + NewSeeded> Reseeder<R> for ReseedWithNew {
    fn reseed(&mut self, rng: &mut R) -> Result<(), Error> {
        R::new().map(|result| *rng = result)
    }
}

#[cfg(test)]
mod test {
    use std::iter::repeat;
    use mock::MockAddRng;
    use {SeedableRng, Rng, iter, Error};
    use super::{ReseedingRng, Reseeder};
    
    #[derive(Debug, Clone)]
    struct ReseedMock;
    impl Reseeder<MockAddRng> for ReseedMock {
        fn reseed(&mut self, rng: &mut MockAddRng) -> Result<(), Error> {
            *rng = MockAddRng::new(0, 1);
            Ok(())
        }
    }

    type MyRng = ReseedingRng<MockAddRng, ReseedMock>;

    #[test]
    fn test_reseeding() {
        let mut rs = ReseedingRng::new(MockAddRng::new(0, 1), 400, ReseedMock);

        let mut i = 0;
        for _ in 0..1000 {
            assert_eq!(rs.next_u32(), i % 100);
            i += 1;
        }
    }

    #[test]
    fn test_rng_seeded() {
        // Default seed threshold is way beyond what we use here
        let seed = [0, 1, 2, 3, 4, 5, 6, 7];
        let mut ra: MyRng = ReseedingRng::from_reseeder(ReseedMock, seed);
        let mut rb = MockAddRng::from_seed(seed);
        assert!(::test::iter_eq(iter(&mut ra).map(|rng| rng.next_u32()).take(100),
                                iter(&mut rb).map(|rng| rng.next_u32()).take(100)));
    }

    const FILL_BYTES_V_LEN: usize = 13579;
    #[test]
    fn test_rng_fill_bytes() {
        let mut v = repeat(0u8).take(FILL_BYTES_V_LEN).collect::<Vec<_>>();
        ::test::rng().fill_bytes(&mut v);

        // Sanity test: if we've gotten here, `fill_bytes` has not infinitely
        // recursed.
        assert_eq!(v.len(), FILL_BYTES_V_LEN);

        // To test that `fill_bytes` actually did something, check that the
        // average of `v` is not 0.
        let mut sum = 0.0;
        for &x in v.iter() {
            sum += x as f64;
        }
        assert!(sum / v.len() as f64 != 0.0);
    }
}
